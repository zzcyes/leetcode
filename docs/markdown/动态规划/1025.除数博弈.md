# 1025.除数博弈

| Title | Describe                                                        |
| :---- | :-------------------------------------------------------------- |
| 题目  | [1025.除数博弈](https://leetcode-cn.com/problems/divisor-game/) |
| 难度  | ⭐                                                              |

## 题目

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字  N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一  x，满足  0 < x < N 且  N % x == 0 。
用 N - x  替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回  True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

示例 1：

```
输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
```

示例 2：

```
输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

提示：

1 <= N <= 1000

## 题解

### 方法一：暴力法

定义一个数组，用来记录选择 x 的值。写个循环，如果满足题目条件就将 x 加入数组中，跳出循环时对数组的长度判断，若为偶数，那么就是鲍勃胜利，反之爱丽丝获胜。

#### 代码

```javascript
/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {
  let x = 1;
  let nums = [];
  while (0 < x < N && N % x == 0) {
    N = N - x;
    nums.push(x);
  }
  return nums.length % 2 == 0;
};
```

### 方法二：数学归纳法

看了题解发现还有数学归纳法，一行代码搞定。

数学小知识：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。

千万不要忽略 1 也是因子！爱丽丝是游戏开始时的先手。

- 当她面对的 N 为偶数时，她一定可以 选到一个 N 的奇数因子 x（比如 1 ），将 N - x 这个奇数传给鲍勃；用 N - x 替换黑板上的数字 N ，鲍勃面对的就是奇数 N，只能选择 N 的奇数因子 x，奇数 - 奇数 = 偶数，此时传给爱丽丝的又是偶数。这样轮换下去爱丽丝会遇到 N = 2 的情形，然后获胜；

- 当爱丽丝遇到的 N 是奇数时，只能传给鲍勃偶数或无法操作 (N = 1) ，无法获胜。

#### 代码

```javascript
/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {
  return N % 2 == 0;
};
```

### 方法三：动态规划

以后在解动态规划提目前可以先思考下数学法，有时候会有意想不到的解法。

1. 确定 dp 含义

还是那个套路，dp[i]往往和 dp[i-1]、dp[i+1]会有着某种关系。

那么 dp[i]可以表示当 N 为 i 时爱丽丝为 true 还是 false。

2. 建立 dp 关系(建立状态转移方程)

- 爱丽丝输的情况（不满足题中条件）：

```
dp[i] =  N % i != 0 || dp[n-i]
```

- 爱丽丝赢的情况（满足题中条件）：

```
dp[i] = N % i == 0 && !dp[n-i]
```

3. 确定边界值。

这里的边界值就很好确定了，直接写下：

```
dp[0] = false;
dp[1] = false;
dp[2] = true;
```

#### 代码

```javascript
/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {
    if(N == 1) return false;
    if(N == 2) return true;
    let dp = [];
    dp[1] = false;
    dp[2] = true;
        dp[i] = false;
        for(let j = 1; j<i; j++){
            if(i % j == 0 && !dp[i - j]){
                dp[i] = true;
                break;
            }
        }
    }
    return dp[N];
};
```
