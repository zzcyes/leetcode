# 198.打家劫舍

| Title | Describe                                                        |
| :---- | :-------------------------------------------------------------- |
| 题目  | [198.打家劫舍](https://leetcode-cn.com/problems/house-robber//) |
| 难度  | ⭐                                                              |

## 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2：

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

提示：

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 400


## 题解

### 方法一：动态规划

为什么感觉这道题与**309.最佳买卖股票时机冷冻期**神似，主要是股票如果当天发生了交易，那么第二天就会进入冷冻期。

这里就是偷窃了一个房屋后，相邻的下一个房屋便不能再偷窃，否则会报警。

<!-- 动态规划的解法，在这道题主要是抓住构建状态转移方程。这里的状态设计到冷冻期，冷冻期意味着前天若设计到买卖股票，那么就无法在第二天买入股票。因此，每一天的状态无非就是持有股票和没有持有股票。

一、dp[i][0] 表示第 i 天没有持有（不一定是当天买入）股票

1.  前一天没有持有股票，今天也不继续持有：dp[i-1][0]
2.  前一天持有股票，今天卖出：dp[i-1][1]+prices[i]

二、dp[i][1]表示第 i 天持有股票

1. 前天卖出，昨天冻结期，今天买入股票 dp[i-2][0]-prices[i]

2. 前天和昨天未持有，今天买入股票 dp[i-2][0]-prices[i]

3. 如果前一天持有股票，今天也继续持有 dp[i-1][1] -->


先试试动态规划三部曲，看看有没有用，没用再说！

1. 确定 dp 含义

还是那个套路，dp[i]往往和 dp[i-1]、dp[i+1]会有着某种关系。

dp[i]表示偷窃房屋i时金额，

2. 建立 dp 关系(建立状态转移方程)

```
dp[i] =Math.min((dp[i - 1] + cost[i]), (dp[i - 2] + cost[i - 1]));
```

3. 确定边界值。

台阶的数组从0开始计数。可以用-1代表地面，并设cost[-1] = 0。

最小总花费的初始值为：

第0级台阶：从地面(-1)到第0级阶梯(0),或者跨过第0级阶梯(0)

```
dp[0] = Math.min(cost[-1], cost[0]) = Math.min(0, cost[0]) = 0，
```

第1级台阶：从第0级阶梯(0)跨过第1级阶梯(1)，或者从地面(-1)到第1级阶梯(1)

```
dp[1] = Math.min(cost[0], cost[1])。
```

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    let len = nums.length;
    if(len===0)return 0;
    if(len===1)return nums[0];
    for(let i=0;i<n;i++){

    }
};
````

