# 64.最小路径和

| Title | Describe                                                            |
| :---- | :------------------------------------------------------------------ |
| 题目  | [64.最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) |
| 难度  | ⭐⭐                                                                |



## 题目

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:
```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

## 题解

### 解法一：动态规划

这题有点像[62.不同路径](./62.不同路径.md)、[63.不同路径II](./63.不同路径II.md)，我们先建立dp关系：

我们可以定义`dp[i] [j]`的含义为：当机器人从左上角走到(i, j) 这个位置时，最小的路径总和是 `dp[i] [j]`。那么，`dp[m-1] [n-1]`就是这道题目我们要求的答案了。

如果要到(i,j)这个位置，有多少种方法呢？通过之前的分析，因为**每次只能相下或者向右移动一步**,那么会有两种走法：

- 从 (i-1, j) 这个位置走一步到达

- 从(i, j - 1) 这个位置走一步到达

当然，这里与[62.不同路径](./62.不同路径.md)、[63.不同路径II](./63.不同路径II.md)的dp状态方程`dp[i][j]=dp[i][j-1]+dp[i-1][j]`不一样，在这道题目中，我们求的是最小路径和，那么可以列出：

```javascript
dp[i][j] = Math.min(dp[i][j-1],dp[i-1][j]) + grid[i][j];
```

到这别急着结束，我们还需要分析当i或j为0时，这个方程怎么办呢？`dp[0][-1]/dp[-1][0]`，数组下表此时-1是不存在的。

这样的话，我们就需要去找这些不能使用表达式的初始的值:

```javascript
dp[0] [j] = grid[0] [j] + dp[0] [j-1]; // 相当于最上面一行，只能一直往右走

dp[i] [0] = grid[i] [0] + dp[i] [0]; // 相当于最左面一列，只能一直往下走
```

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    let{ length:m } = grid;
    let{ length:n } = grid[0];
    if (m <= 0 || n <= 0) {
        return 0;
    }
    let dp = new Array(m).fill().map(() => new Array(n).fill([]));

    dp[0][0] = grid[0][0];

    for(let i = 1; i < m; i++){
      dp[i][0] = dp[i-1][0] + grid[i][0];
    }

    for(let i = 1; i < n; i++){
      dp[0][i] = dp[0][i-1] + grid[0][i];
    }

    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
};
```



